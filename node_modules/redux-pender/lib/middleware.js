"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("proxy-polyfill");
var utils_1 = require("./utils");
var PENDING = utils_1.actionTypes.PENDING, SUCCESS = utils_1.actionTypes.SUCCESS, FAILURE = utils_1.actionTypes.FAILURE, CANCEL = utils_1.actionTypes.CANCEL;
var _id = 0;
function generatePenderId() {
    _id += 1;
    return _id;
}
function isPromise(promise) {
    if (!promise)
        return false;
    return promise.then && promise.catch;
}
function getPromise(action, major) {
    var payload = action.payload;
    if (!payload)
        return null;
    if (major) {
        if (isPromise(payload))
            return payload;
    }
    var pend = action.payload.pend;
    if (isPromise(pend))
        return pend;
    return null;
}
function penderMiddleware(config) {
    if (config === void 0) { config = { major: true, raw: false }; }
    var major = config.major === undefined ? true : config.major;
    return function (store) { return function (next) { return function (action) {
        // retrieve Promise if possible
        var promise = getPromise(action, major);
        if (!promise)
            return next(action); // skip if no promise found
        var type = action.type, meta = action.meta;
        var actions = utils_1.penderize(type);
        var cancelled = false;
        // promise start
        store.dispatch({
            type: actions.PENDING,
            meta: meta,
        });
        // inform pender reducer
        store.dispatch({
            type: PENDING,
            payload: type,
        });
        // use proxy to handle promise cancellation
        var origin = {
            cancel: false,
            resolve: false,
        };
        var proxy = null;
        var cancelPromise = new Promise(function (resolve, reject) {
            var handler = {
                set: function (target, key, value) {
                    if (key === 'cancel') {
                        cancelled = true;
                        store.dispatch({
                            type: CANCEL,
                            payload: type,
                        });
                        store.dispatch({
                            type: actions.CANCEL,
                            meta: meta,
                        });
                        reject(new Error(type + " is cancelled"));
                        proxy = null;
                        return true;
                    }
                    if (key === 'resolve') {
                        resolve();
                        return true;
                    }
                    return true;
                },
            };
            proxy = new Proxy(origin, handler);
        });
        var cancel = function () {
            if (!proxy)
                return;
            proxy.cancel = true;
        };
        promise
            .then(function (result) {
            if (cancelled)
                return; // do nothing if cancelled
            if (!proxy)
                return;
            proxy.resolve = true;
            proxy = null;
            // promise resolved
            store.dispatch({
                type: actions.SUCCESS,
                payload: result,
                meta: meta,
            });
            // inform pender reducer
            store.dispatch({
                type: SUCCESS,
                payload: type,
            });
        })
            .catch(function (e) {
            if (cancelled)
                return; // do nothing if cancelled
            if (!proxy)
                return;
            proxy.resolve = true;
            proxy = null;
            // promise rejected
            store.dispatch({
                type: actions.FAILURE,
                payload: e,
                error: true,
                meta: meta,
            });
            // inform pender reducer
            store.dispatch({
                type: FAILURE,
                payload: type,
            });
        });
        var cancellablePromise = Promise.race([
            promise,
            cancelPromise,
        ]);
        cancellablePromise.cancel = cancel;
        if (config.raw) {
            return {
                type: type,
                meta: meta,
                payload: cancellablePromise,
            };
        }
        return cancellablePromise;
    }; }; };
}
exports.default = penderMiddleware;
